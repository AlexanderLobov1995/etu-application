<div *mobxAutorun class="container">
    <app-header></app-header>
    <div class="content">
        <app-navigation></app-navigation>
        <div [style.transform]="'translateY('+ navigationState.pageOffset + 'vh)'" class="page-content">
            <div class="page page-1">
                <div *ngIf="!authState.token" class="auth-content">
                    <div class="block-1">
                        <h1>Authorization guide. Узнай больше о web-безопасности</h1>
                        <img src="./images/web-security.jpg" alt="web-security-image">
                        <p>Довольно важной задачей при разработке веб-сайтов и веб-приложений есть ограничение доступа к некоторым разделам сайта, например к панели администратора. В теории это достаточно сложный процесс, с трема составляющими: </p>
                        <ul>
                            <li>аутентификация (англ. authentication)</li>
                            <li>идентификация (англ. identification)</li>
                            <li>авторизация (англ. authorization)</li>
                        </ul>
                        <p>Данное приложение отображает основы работы, такие как:</p>
                        <ul>
                            <li>Методы HTTP (PUT, GET, DELETE, POST)</li>
                            <li>oAuth</li>
                            <li>JWT tokens</li>
                            <li>Политика безопасности по ролям</li>
                        </ul>
                        <p>Всю подробную информацию можете найти здесь</p>
                    </div>
                    <app-signup></app-signup>
                </div>
                <app-todo-area *ngIf="authState.token"></app-todo-area>
                <app-todo-logger *ngIf="appState.showLogger" [loggs]="loggerState.loggs"></app-todo-logger>
            </div>
            <div class="page">
                <h1>Что такое JSON Web Token?</h1>
                <p>JSON Web Token (JWT) является открытым стандартом (RFC 7519), который определяет компактный и автономный способ для безопасной передачи информации между сторонами как объект JSON. Эта информация может быть проверена и доверена, поскольку она имеет цифровую подпись. JWT могут быть подписаны с использованием секретного (с алгоритмом HMAC) или пары открытого / закрытого ключей с использованием RSA.</p>
                <h1>Поясним некоторые концепции.</h1>
                <ul>
                    <li><b>Компактность:</b> Из-за их меньшего размера JWT можно отправлять через URL-адрес, параметр POST или внутри HTTP-заголовка. Кроме того, меньший размер означает, что передача выполняется быстро.</li>
                    <li><b>Автономный:</b> Payload содержит всю необходимую информацию о пользователе, избегая необходимости запрашивать базу данных более одного раза.</li>
                </ul>
                <h1>Когда должны использовать JSON Web Tokens?</h1>
                <ul>
                    <li><b>Аутентификация:</b> Это самый распространенный сценарий использования JWT. Как только пользователь войдет в систему, каждый последующий запрос будет включать JWT, позволяя пользователю получать доступ к роутам, сервисам, и ресурсы, которые разрешены с помощью этого токена. Single Sign On - это возможность, которая широко использует JWT в настоящее время, из-за его небольших накладных расходов и его способности легко использоваться в разные домены.
                    </li>
                    <li><b>Обмен информацией:</b> Веб-токены JSON - это хороший способ безопасного передавая информацию между сторонами. Поскольку JWT можно подписать, например, используя пары открытого / закрытого ключа - вы можете быть уверены, что отправители - это те, кем они говорят. Кроме того, поскольку подпись вычисляется с использованием header  и payload, вы также можете убедиться, что контент не был изменен.
                    </li>
                </ul>
                <h1>Структура JSON Web Tokens</h1>
                <p>JSON Web Tokens состоит из трех частей, разделенных точками (.):</p>
                <ul>
                    <li>Header</li>
                    <li>Payload</li>
                    <li>Signature</li>
                </ul>
                <p>JWT обычно выглядит следующим образом.</p>
                <b>xxxxx.yyyyy.zzzzz</b>
                <h2>Header</h2>
                <p>Header обычно состоит из двух частей: типа токена, который является JWT, и используемого алгоритма хеширования, такого как HMAC SHA256 или RSA.</p>
                <pre>
                        <code>
{{'{'}}
    "alg": "HS256",
    "typ": "JWT"
{{'}'}}
                        </code>
                 </pre>
                <p>Затем этот JSON кодируется <b>Base64Url</b>, чтобы сформировать первую часть JWT.</p>
                <h2>Payload</h2>
                <p>Вторая часть токена - payload, которая содержит формулы изобретения. Claims - это утверждения об объекте (обычно, пользователь) и дополнительных метаданных. Существует три типа claims: зарегистрированные, публичные и частные claims.</p>
                <ul>
                    <li><b>Зарегистрированные claims:</b> это набор предопределенных claims, которые не являются обязательными, но рекомендуемыми, для предоставления набора полезных, совместимых claims. Некоторые из них: iss (issuer), exp (expiration time), sub (subject), aud (audience) и другие.</li>
                    <li><b>Публичные claims:</b> они могут быть определены по желанию теми, кто использует JWT. Но чтобы избежать коллизий, они должны быть определены в реестре веб-токенов IANA JSON или быть определены как URI, который содержит пространство с устойчивостью к конфликтам.</li>
                    <li><b>Частные claims:</b> Это индивидуальные требования, созданные для обмена информацией между сторонами, которые согласны с их использованием, и не являются ни зарегистрированными, ни публичными требованиями.</li>
                </ul>
                <p>Пример payload может быть:</p>
                <pre>
                        <code>
{{'{'}}
    "sub": "1234567890",
    "name": "John Doe",
    "admin": true
{{'}'}}
                        </code>
                 </pre>
                <p>Затем payload кодируется <b>Base64Url</b> для формирования второй части веб-маркера JSON.</p>
                <h2>Signature</h2>
                <p>Чтобы создать часть подписи, вы должны взять закодированный заголовок, закодированную полезную нагрузку, секрет, алгоритм, указанный в заголовке, и подписать это.</p>
                <p>Например, если вы хотите использовать алгоритм HMAC SHA256, подпись будет создана следующим образом:</p>
                <pre>
                        <code>
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
                        </code>
                 </pre>
                <p>Подпись используется для проверки того, что сообщение не было изменено на этом пути, а в случае токенов, подписанных с закрытым ключом, также может убедиться, что отправителем JWT является тот, кто это говорит.</p>
                <p>Подробная информация: <a target="_blank" href="https://jwt.io/introduction/">https://jwt.io/introduction/</a></p>
            </div>
            <div class="page">
                <h1>Ролевая политика безопасности</h1>
                <article><b>Ролевая политика безопасности</b> представляет собой существенно усовершенствованную модель Харрисона–Руззо–Ульмана, однако ее нельзя отнести ни к дискреционным, ни к мандатным моделям.</article>
                <article>В ролевой политике безопасности классическое понятие субъекта заменяется понятиями пользователь и роль. </article>
                <article><b>Пользователь</b> – это человек, работающий с системой и выполняющий определенные служебные обязанности, а с понятием роли связывается набор полномочий, необходимых для выполнения этих служебных обязанностей.</article>
            </div>
        </div>
    </div>
</div>
<app-popup (close)="onClosePopup()">
    <app-auth *ngIf="appState.showAuthDialog"></app-auth>
    <app-create-todo *ngIf="appState.showCreateDialog"></app-create-todo>
    <app-update-todo *ngIf="appState.showUpdateDialog" [todo]="appState.updateTodo"></app-update-todo>
</app-popup>